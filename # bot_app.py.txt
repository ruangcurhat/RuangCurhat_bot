# bot_app.py
import os
import time
import threading
import sqlite3
import requests
from flask import Flask, request, jsonify
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, filters, ContextTypes

# --- Konfigurasi via ENV ---
BOT_TOKEN = os.environ.get("BOT_TOKEN")           # dari BotFather
XENDIT_API_KEY = os.environ.get("XENDIT_API_KEY") # secret key Xendit
ADMIN_CHAT_ID = int(os.environ.get("ADMIN_CHAT_ID", "0"))  # chat id grup konselor
PORT = int(os.environ.get("PORT", "5000"))

# --- Database sederhana (SQLite) ---
DB = "bot.db"
def init_db():
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS clients (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   telegram_id INTEGER UNIQUE,
                   created_at INTEGER
                 )''')
    c.execute('''CREATE TABLE IF NOT EXISTS sessions (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   client_id INTEGER,
                   reference_id TEXT,
                   active INTEGER,
                   expires_at INTEGER
                 )''')
    c.execute('''CREATE TABLE IF NOT EXISTS curhats (
                   id INTEGER PRIMARY KEY AUTOINCREMENT,
                   client_id INTEGER,
                   text TEXT,
                   ts INTEGER
                 )''')
    conn.commit()
    conn.close()

def get_or_create_client(telegram_id):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT id FROM clients WHERE telegram_id=?", (telegram_id,))
    row = c.fetchone()
    if row:
        cid = row[0]
    else:
        c.execute("INSERT INTO clients (telegram_id, created_at) VALUES (?, ?)", (telegram_id, int(time.time())))
        cid = c.lastrowid
        conn.commit()
    conn.close()
    return cid

def create_session(client_id, reference_id, duration_seconds=3600):
    expires = int(time.time()) + duration_seconds
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("UPDATE sessions SET active=0 WHERE client_id=?", (client_id,))
    c.execute("INSERT INTO sessions (client_id, reference_id, active, expires_at) VALUES (?, ?, ?, ?)",
              (client_id, reference_id, 1, expires))
    conn.commit()
    conn.close()

def end_session_by_client(client_id):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("UPDATE sessions SET active=0 WHERE client_id=?", (client_id,))
    conn.commit()
    conn.close()

def is_session_active(client_id):
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    now = int(time.time())
    c.execute("SELECT id, expires_at FROM sessions WHERE client_id=? AND active=1", (client_id,))
    row = c.fetchone()
    conn.close()
    if not row:
        return False
    _, expires_at = row
    if expires_at < now:
        end_session_by_client(client_id)
        return False
    return True

# --- Telegram handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Halo! Saya bot curhat anonim ðŸ¤–\n\n"
        "Kirim pesan apapun untuk curhat GRATIS (pesanmu akan diteruskan ke konselor).\n"
        "Jika ingin sesi pribadi 1 jam (Rp15.000), ketik /book."
    )

async def book(update: Update, context: ContextTypes.DEFAULT_TYPE):
    tg_user = update.effective_user
    client_id = get_or_create_client(tg_user.id)
    amount = 15000
    reference_id = f"session_{client_id}_{int(time.time())}"
    payload = {
        "amount": amount,
        "currency": "IDR",
        "description": "Sesi Konseling 1 jam (anonim)",
        "reference_id": reference_id
    }
    resp = requests.post(
        "https://api.xendit.co/v2/payment_links",
        auth=(XENDIT_API_KEY, ''),
        json=payload
    )
    if resp.status_code in (200, 201):
        data = resp.json()
        url = data.get("url") or data.get("checkout_url") or data.get("invoice_url")
        if url:
            await update.message.reply_text(
                f"Silakan bayar Rp{amount:,} di link ini:\n{url}\n"
                "Setelah bayar, sesi 1 jam akan aktif otomatis."
            )
            conn = sqlite3.connect(DB)
            c = conn.cursor()
            c.execute("INSERT INTO sessions (client_id, reference_id, active, expires_at) VALUES (?, ?, ?, ?)",
                      (client_id, reference_id, 0, 0))
            conn.commit()
            conn.close()
        else:
            await update.message.reply_text("Gagal membuat link pembayaran.")
    else:
        await update.message.reply_text("Gagal membuat link pembayaran. Coba lagi nanti.")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.type != "private":
        return
    user = update.effective_user
    text = update.message.text or ""
    client_id = get_or_create_client(user.id)

    if is_session_active(client_id):
        label = f"Klien #{client_id} (SESI AKTIF)"
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"{label}:\n{text}")
        await update.message.reply_text("Pesan terkirim ke konselor.")
        return

    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("INSERT INTO curhats (client_id, text, ts) VALUES (?, ?, ?)", (client_id, text, int(time.time())))
    conn.commit()
    conn.close()

    await update.message.reply_text(
        "Terima kasih sudah berbagi ðŸ™ Pesanmu diteruskan ke konselor.\n"
        "Jika ingin sesi pribadi 1 jam, ketik /book."
    )
    await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"NEW CURHAT â€” Klien #{client_id}:\n{text}")

# Konselor reply: /reply <client_id> <pesan>
async def reply_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    args = context.args
    if len(args) < 2:
        await update.message.reply_text("Usage: /reply <client_id> <pesan>")
        return
    client_id = int(args[0])
    pesan = " ".join(args[1:])
    conn = sqlite3.connect(DB)
    c = conn.cursor()
    c.execute("SELECT telegram_id FROM clients WHERE id=?", (client_id,))
    row = c.fetchone()
    conn.close()
    if not row:
        await update.message.reply_text("Client ID tidak ditemukan.")
        return
    tg_id = row[0]
    await context.bot.send_message(chat_id=tg_id, text=f"Konselor: {pesan}")
    await update.message.reply_text("Terkirim ke klien.")

async def end_session_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_chat.id != ADMIN_CHAT_ID:
        return
    if len(context.args) < 1:
        await update.message.reply_text("Usage: /endsession <client_id>")
        return
    client_id = int(context.args[0])
    end_session_by_client(client_id)
    await update.message.reply_text(f"Sesi Klien #{client_id} diakhiri.")

# --- Flask app untuk webhook ---
flask_app = Flask(__name__)

@flask_app.route("/xendit_webhook", methods=["POST"])
def xendit_webhook():
    data = request.json or {}
    reference = data.get("reference_id") or data.get("external_id")
    status = data.get("status")
    if reference and status and status.lower() in ("paid", "completed", "success"):
        conn = sqlite3.connect(DB)
        c = conn.cursor()
        c.execute("SELECT client_id FROM sessions WHERE reference_id=?", (reference,))
        row = c.fetchone()
        conn.close()
        if row:
            client_id = row[0]
            create_session(client_id, reference, duration_seconds=3600)
            from telegram import Bot
            bot = Bot(token=BOT_TOKEN)
            bot.send_message(chat_id=ADMIN_CHAT_ID, text=f"Sesi aktif: Klien #{client_id} â€” 1 jam dimulai.")
    return jsonify({"ok": True})

def run_flask():
    flask_app.run(host="0.0.0.0", port=PORT)

def main():
    init_db()
    t = threading.Thread(target=run_flask, daemon=True)
    t.start()

    application = ApplicationBuilder().token(BOT_TOKEN).build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("book", book))
    application.add_handler(CommandHandler("reply", reply_cmd))
    application.add_handler(CommandHandler("endsession", end_session_cmd))
    application.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_message))
    application.run_polling()

if __name__ == "__main__":
    main()
